version = 0.1
[[template]]
name = "babel"
definition = """({ name, targets, deps, env, templateOptions: { presets = [], plugins = [], sourceMap = true, noBabelRc = false, configFile = null, autoInstall } }) => {
  const defaultConfig = {};
  return [{
    name,
    targets,
    deps: [...deps, ...noBabelRc ? [] : ['.babelrc'], ...presets.map(p => `node_modules/${p}`), ...plugins.map(p => `node_modules/${p}`), 'node_modules/@babel/core', 'node_modules/@babel/cli'],
    env,
    run: `babel $DEP -o $TARGET${
        sourceMap ? ' --source-maps' : ''
      }${
        plugins.length ? ` --plugins=${plugins.join(',')}` : ''
      }${
        presets.length ? ` --presets=${presets.join(',')}` : ''
      }${
        noBabelRc ? ' --no-babelrc' : ''
      }${
        configFile ? ` --config-file=${configFile.startsWith('./') ? configFile : './' + configFile}` : ''
      }`
  }, {
    target: '.babelrc',
    targetCheck: 'exists',
    run: `
      echo '\n\\x1b[93mChomp\\x1b[0m: Creating \\x1b[1m.babelrc\\x1b[0m (set \\x1b[1m"no-babel-rc = true"\\x1b[0m Babel template option to skip)\n'
      echo '${JSON.stringify(defaultConfig, null, 2)}' > .babelrc
    `
  }, {
    template: 'npm',
    templateOptions: {
      packages: [...presets.map(p => p.startsWith('@babel/') ? p + '@7' : p), ...plugins.map(p => p.startsWith('@babel/') ? p + '@7' : p), '@babel/core@7', '@babel/cli@7'],
      dev: true,
      autoInstall
    }
  }];
}
"""
[[template]]
name = "cargo"
definition = """({ deps, env, templateOptions: { bin, install } }, globalEnv) => {
  const sep = globalEnv.PATH.match(/\\\\|\\//)[0];
  return [{
    name: `cargo:${bin}`,
    targets: [globalEnv.PATH.split(';').find(p => p.endsWith(`.cargo${sep}bin`)) + sep + bin + (sep === '/' ? '' : '.exe')],
    targetCheck: 'exists',
    deps,
    env,
    run: `cargo install ${install}`
  }];
}
"""
[[template]]
name = "jspm"
definition = """({ name, targets, deps, env, templateOptions: {
  autoInstall,
  env: generatorEnv = ['browser', 'production', 'module'],
  preload,
  integrity,
  whitespace,
  esModuleShims,
  ...generateOpts
} }) => [{
  name,
  targets,
  targetCheck: 'always-rebuild',
  deps: [...deps, 'node_modules/@jspm/generator', 'node_modules/mkdirp'],
  env,
  engine: 'node',
  run: `
    import { Generator } from '@jspm/generator';
    import { readFile, writeFile } from 'fs/promises';
    import { pathToFileURL } from 'url';
    import mkdirp from 'mkdirp';
    import { dirname, relative, resolve } from 'path';

    const importMapTarget = process.env.TARGET.endsWith('.importmap');

    const opts = ${JSON.stringify(generateOpts)};
    const htmlUrl = importMapTarget ? null : pathToFileURL(process.env.TARGET);

    if (opts.resolutions) {
      const newResolutions = {};
      // renormalize relative resolutions relative to cwd
      const cwd = process.cwd();
      for (const key of Object.keys(opts.resolutions)) {
        const target = opts.resolutions[key];
        if (!target.startsWith('./') && !target.startsWith('../')) {
          newResolutions[key] = target;
          continue;
        }
        const normalizedTarget = relative(dirname(resolve(cwd, process.env.TARGET)), resolve(cwd, target)).replace(/\\\\\\\\/g, '/');
        newResolutions[key] = normalizedTarget;
      }
      opts.resolutions = newResolutions;
    }

    const generator = new Generator({
      mapUrl: htmlUrl || import.meta.url,
      env: ${JSON.stringify(generatorEnv)},
      ...opts
    });

    if (importMapTarget) {
      let deps = [];
      let i = 0;
      while (++i) {
        const dep = process.env['DEP' + i];
        if (dep === 'node_modules/@jspm/generator' || dep === 'node_modules/mkdirp')
          continue;
        if (dep === undefined)
          break;
        deps.push(dep);
      }
      await Promise.all(deps.map(dep => generator.traceInstall('./' + dep)));
      await writeFile(process.env.TARGET, JSON.stringify(generator.getMap(), null, 2));
    }
    else {
      const htmlSource = await readFile(process.env.DEP, 'utf-8');
      const htmlOpts = ${JSON.stringify({ preload, integrity, whitespace, esModuleShims })};
      htmlOpts.htmlUrl = htmlUrl;
      const outHtml = await generator.htmlGenerate(htmlSource, htmlOpts);

      mkdirp.sync(dirname(process.env.TARGET));
      await writeFile(process.env.TARGET, outHtml);
    }
  `
}, {
  template: 'npm',
  templateOptions: {
    autoInstall,
    packages: ['@jspm/generator', 'mkdirp'],
    dev: true
  }
}]
"""
[[template]]
name = "npm"
definition = """({ name, deps, env, templateOptions: { packages, dev, packageManager = 'npm', autoInstall } }) => autoInstall ? [{
  name,
  deps: [...deps, ...packages.map(pkg => {
    const versionIndex = pkg.indexOf('@', 1);
    return `node_modules/${versionIndex === -1 ? pkg : pkg.slice(0, versionIndex)}`;
  })],
  serial: true
}, ...packages.map(pkg => {
  const versionIndex = pkg.indexOf('@', 1);
  return {
    target: `node_modules/${versionIndex === -1 ? pkg : pkg.slice(0, versionIndex)}`,
    targetCheck: 'exists',
    deps: ['npm:init'],
    env,
    run: `${packageManager} install ${packages.join(' ')}${dev ? ' -D' : ''}`
  };
}), {
  name: 'npm:init',
  target: 'package.json',
  targetCheck: 'exists',
  env,
  run: `${packageManager} init -y`
}] : [{
  name,
  env,
  targetCheck: 'exists',
  targets: packages.map(pkg => {
    const versionIndex = pkg.indexOf('@', 1);
    return `node_modules/${versionIndex === -1 ? pkg : pkg.slice(0, versionIndex)}`;
  }),
  run: `echo "\n\\x1b[93mChomp\\x1b[0m: Some packages are missing. Please run \\x1b[1m${packageManager} install ${packages.join(' ')}${dev ? ' -D' : ''}\\x1b[0m\n"`
}];
"""
[[template]]
name = "prettier"
definition = """({ name, targets, deps, env, templateOptions: { files = '.', check = false, write = true, config = null, noErrorOnUnmatchedPattern = false, autoInstall } }) => [{
  name,
  targets,
  deps: [...deps, 'node_modules/prettier'],
  env,
  run: `prettier ${files} ${
      check ? ' --check' : ''
    }${
      write ? ' --write' : ''
    }${
      config ? ` --config ${config}` : ''
    }${
      noErrorOnUnmatchedPattern ? ' --no-error-on-unmatched-pattern' : ''
    }`
}, {
  template: 'npm',
  templateOptions: {
    autoInstall,
    packages: ['prettier'],
    dev: true
  }
}]
"""
[[template]]
name = "svelte"
definition = """({ name, targets, deps, env, templateOptions: { svelteConfig = null, autoInstall } }) => [{
  name,
  targets,
  deps: [...deps, 'node_modules/svelte', 'node_modules/mkdirp'],
  env,
  engine: 'node',
  run: `
    import { readFile, writeFile } from 'fs/promises';
    import { compile } from 'svelte/compiler';
    import mkdirp from 'mkdirp';
    import { dirname } from 'path';

    let config;
    ${svelteConfig ? `
      config = await import(${svelteConfig === true ? '"./svelte.config.js"' : svelteConfig});
    ` : `
      config = {
        css: false
      };
    `}
    config.filename = process.env.DEP;

    const source = await readFile(process.env.DEP, 'utf-8');
    const result = compile(source, config);

    mkdirp.sync(dirname(process.env.TARGET));
    const cssFile = process.env.TARGET.replace(/\\.js$/, ".css");
    await Promise.all[
      writeFile(process.env.TARGET, result.js.code),
      writeFile(process.env.TARGET + ".map", JSON.stringify(result.js.map)),
      writeFile(cssFile, result.css.code),
      writeFile(cssFile + ".map", JSON.stringify(result.css.map))
    ];
  `
}, {
  template: 'npm',
  templateOptions: {
    autoInstall,
    packages: ['svelte@3', 'mkdirp'],
    dev: true
  }
}]
"""
[[template]]
name = "swc"
definition = """({ name, targets, deps, env, templateOptions: { configFile = null, noSwcRc = false, sourceMaps = true, config = {}, autoInstall } }, globalEnv) => {
  const isWin = globalEnv.PATH.match(/\\\\|\\//)[0] !== '/';
  const defaultConfig = {
    jsc: {
      parser: {
        syntax: 'typescript',
        importAssertions: true,
        topLevelAwait: true,
        importMeta: true,
        privateMethod: true,
        dynamicImport: true
      }/*,
      experimental: {
        keepImportAssertions: true
      }*/ // TODO: reenable when supported
    }
  };
  function setDefaultConfig (config, defaultConfig, base = '') {
    for (const prop of Object.keys(defaultConfig)) {
      const val = defaultConfig[prop];
      if (typeof val === 'object') {
        setDefaultConfig(config, defaultConfig[prop], base + prop + '.');
      }
      else if (!((base + prop) in config)) {
        config[base + prop] = defaultConfig[prop];
      }
    }
  }
  if (noSwcRc) {
    setDefaultConfig(config, defaultConfig);
  }
  return [{
    name,
    targets,
    deps: [...deps, ...noSwcRc ? [] : ['.swcrc'], 'node_modules/@swc/core', 'node_modules/@swc/cli'],
    env,
    run: `node ./node_modules/@swc/cli/bin/swc.js $DEP -o $TARGET${
        noSwcRc ? ' --no-swcrc' : ''
      }${
        configFile ? ` --config-file=${configFile}` : ''
      }${
        sourceMaps ? ' --source-maps' : ''
      }${
        Object.keys(config).length ? ' ' + Object.keys(config).map(key => `-C ${key}=${config[key]}`).join(' ') : ''
      }`
  }, {
    target: '.swcrc',
    targetCheck: 'exists',
    run: `
      echo '\n\\x1b[93mChomp\\x1b[0m: Creating \\x1b[1m.swcrc\\x1b[0m (set \\x1b[1m"no-swc-rc = true"\\x1b[0m SWC template option to skip)\n'
      ${isWin // SWC does not like a BOM... Powershell hacks...
        ? `$encoder = new-object System.Text.UTF8Encoding ; Set-Content -Value $encoder.Getbytes('${JSON.stringify(defaultConfig, null, 2)}') -Encoding Byte -Path $TARGET`
        : `echo '${JSON.stringify(defaultConfig)}' > $TARGET`
      }
    `
  }, {
    template: 'npm',
    templateOptions: {
      autoInstall,
      packages: ['@swc/core@1', '@swc/cli@0.1'],
      dev: true
    }
  }];
}
"""
